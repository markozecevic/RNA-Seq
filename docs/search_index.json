[
["index.html", "Analiza RNA-Seq podataka Podesavanja", " Analiza RNA-Seq podataka marko.zecevic@sbgenomics.com 2020-03-26 Podesavanja Linux okruzenje sa instaliranim neophodnim paketima i RStudiom je dokerizovano i postavljeno na Docker Hub. Nakon instalacije Docker-a, potrebno je odraditi pull (~4.3 GB download). docker pull markoz/rnastudio Zatim treba klonirati GitHub repo sa meterijalima. git clone git@github.com:markozecevic/RNA-Seq.git Kada u lokalu imate i Docker image i materijale, pokrenucete Docker kontejner komandom (potrebno je zameniti /putanja/do/repozitorijuma/RNA-Seq sa pravom putanjom kloniranog repozitorijuma): docker run -e PASSWORD=etf -p 8787:8787 -v /putanja/do/repozitorijuma/RNA-Seq:/home/rstudio/materijali -e ROOT=TRUE markoz/rnastudio U browseru otvoriti http://localhost:8787/ (user: “rstudio, pass:”etf&quot;). Sledece komande ce podesiti radni folder i izrenderovati materijale: setwd(&quot;~/materijali&quot;) bookdown::render_book(&quot;index.Rmd&quot;, &quot;bookdown::gitbook&quot;) "],
["uvod.html", "1 Uvod 1.1 Centralna dogma molekularne biologije 1.2 Transkripti 1.3 Analysis goals 1.4 Sample preparation 1.5 DNK mikročip (microarray) 1.6 RNA-Seq", " 1 Uvod Dezoksiribonukleinska kiselina (DNA) je molekul nosilac naslednih informacija. Kod eukariotskih organizama, najveci broj ovih molekula nalazi se u jedru celije, a manji broj u organelama kao sto su mitohondrije i hloroplasti (u biljkama). Uglavnom je organizovana u hromozome - dugačke vlaknaste strukture. Kod čoveka je hromozom dvostruki, spiralno uvijeni lanac od 50 do 250 miliona nukleotida. Jedan segment tog niza koji kodira molekul ribonukleinske kiseline (RNA) naziva se gen, a ceo skup genetskih instrukcija koje nosi neki organizam - genom. Humani genom sadrži više od 20,000 gena. RNA kao i DNA molekuli su nizovi nukleotida. Nukleotidi koji čine DNA su adenin (A), guanin (G), citozin (C) i timin (T), dok se kod RNA timin zamenjuje uracilom (U). Svaka ćelija našeg organizma sadrzi praktično istu DNA (osim u haploidnim polnim ćelijama), ali neke od tih ćelija vrše potpuno različite funkcije. Folikularna celija stitaste zlezde i glatka misicna ćelija ocigledno imaju drasticno razlicit metabolizam, ali kako kada je osnovni genetski kod isti? 1.1 Centralna dogma molekularne biologije (pre)pojednostavljeno: “DNA gradi RNA, RNA gradi proteine, proteini grade nas.” Centralna dogma molekularne biologije definise glavni smer toka biološke informacije: DNA kodira RNA, a RNA kodira protein. U ovom toku informacije razlikujemo tri glavna procesa: Informacija sadržana u segmentu DNA niza se može kopirati u RNA kroz proces koji nazivamo transkripcija uz posredstvo enzima RNA-polimeraze. Informacijska RNA (mRNA) nastaje od pre-mRNA procesom splajsovanja, u kojem se uklanjaju tzv. intronske regije (introni). Translacijom nazivan proces sintetizovanja proteina nizanjem amino kiselina po mRNA šablonu. Translacija se obavlja unutar ribozoma - organele sačinjene od ribozomalne RNA (rRNA) i proteina. Ovo je pojednostavljeno vidjenje jer postoje i efekti suprotnog smera. Intinuitivno nam je jasno da aktivnost odredjenog gena varira u vremenu i od celije do celije - dakle neki sistem regulacije postoji. Promoterski region je segment duzine 100-1000 baza koji se nalazi uz gen na 5’ strani. Ovde se inicijalno vezuje RNA-polimeraza i zapocinje proces transkripcije. Pojacivaci (enhancers) mogu biti i udaljeni od pocetka gena i locirani u bilo kom pravcu. Na njih se vezuju transcription faktori koji interaguju sa RNA-polimerazom i tako povećavaju šansu da dođe to transkripcije. Postoje i regioni koje imaju suprotnu regulatornu ulogu. Prvi proizvod transkripcije je takozvani primarni transkript (pre-mRNA). On je doslovno prepisan coding strand od pocetka do kraja gena, osim sto je svako T zamenjeno sa U1. U procesu formiranja zrele RNA intronske sekvence bivaju uklonjene. Sinteza proteina se obavlja u ribozomima u procesu u kojem se kod zapisan sa cetiri nukleinske kiseline prevodi u kod 20 aminokiselina koje se nizu po odredjenom obrascu. Ulogu prevodioca igraju tRNA molekuli koji jednim svojim krajem prepoznaju odgovarajuci (komplementaran) kodon2 na mRNA, a na drugom kraju nose odgovarajuću aminokiselinu. UTR = untranslated region, ne kodira protein. Spomenuli smo ribozome i tRNA, pa je vreme da napomenemo da postoji vise vrsta RNA molekula: informacijska (mRNA), transfer RNA (tRNA), ribosomalna RNA (rRNA), kratka i duga nekodirajuca RNA (ncRNA). Informacijska ili messenger RNA (mRNA) zastupljena je sa oko ~5% u ćelijama sisara, ribozomalna RNA (rRNA) ~80%, transportna RNA koja takođe učestvuje u procesu translacije (tRNA) ~15% … 1.2 Transkripti Od jednog gena, nakon slajsinga, mogu nastati razlicite varijante mRNA molekula koje nazivamo transkripti (ili izoforme). Ekvivalentno relaciji gen-genom, ‘katalog’ svih mogućih transkripata zovemo transkritom. Alternativno splajsovanje je proces kojim od pre-mRNA koji je doslovno prepisan DNA kod nastaje mRNA koji će kodirati protein. Splajsovanjem dolazi do odstranjivanja intronskih regija (introna), ali se isto može desiti i pojedinim eksonima. Rezultujući različiti mRNA molekuli mogu biti translirani u različite proteine, odnosno - jedan gen može da kodira više proteina. Alternativno splajsovanje se javlja kao normalna pojava kod eukariota, gde znatno povećava raznovrsnost proteina. Kod ljudi preko 80% gena su alternativno splajsovani. Brojni modovi alternativnog splajsovanja su uočeni, od kojih najčešći jeste preskakanje eksona. U tom modu, pojedini ekson može biti uključen u mRNA pod nekim uslovima ili u pojedinim tkivima, i izostavljen iz mRNA u drugim. Ovo je nešto što će otežati problem alignmenta (poravnanja) na referentni genom. Aligner mora biti ‘splice aware’! 1.3 Analysis goals Reconstruct the full set of transcripts (isoforms) of genes that were present in the original cells. This catalogue of transcripts is called transcriptome. Estimate the expression levels for all transcripts. Why measure gene expression? Proteini (belančevine) predstavljaju za žive sisteme najznačajnije organske molekule. Osim što izgrađuju ćeliju i njene delove, proteini obavljaju i sve osnovne funkcije u organizmu. Izuzetno je komplikovano direktno izmeriti relativnu zastupljenost određenog proteina u uzorku. Zato merimo relativnu zastupljenost mRNA molekula koji kodira taj protein! Because gene expression correlates with protein expression! Even though nearly every cell in an organism’s body contains the same set of genes, only a fraction of these genes are used in any given cell at any given time. It is this carefully controlled pattern of what is called “gene expression” that makes a liver cell different from a muscle cell, and a healthy cell different from a cancer cell. By measuring gene expression, we can identify active and inactive genes in a cell or tissue. This knowledge is important for drug discovery and creating diagnostic tests. 1.4 Sample preparation Choosing the appropriate protocol: Most of the RNA in a cell is ribosomal RNA (an RNA component of ribosome which is approx 60% rRNA and 40% protein). This is an issue since most scientists (and enthusiasts like us) will be interested in mRNA because of its protein coding function. There are two popular methods for increasing mRNA concentration in your samples: poly (A) capture ribosomal RNA depletion There are also total-RNA protocols that do not enrich for a specific RNA type - for “total RNA” studies; Different fragment sizes; Bulk or single cell RNA-Seq; … Then what? Microarrays or RNA-Seq! 1.5 DNK mikročip (microarray) U upotrebi od kasnih 80ih, DNK mikročip je mikroskopski slajd na kojem je matrica sa više hiljada polja. Svako polje sadrži nekoliko pikomola specifične DNK sekvence - probe, koje detektuju gensku ekspresiju. Molekuli RNA uzorka su obelezeni floroscentnim probama. Ovi molekuli se vezuju za sebi komplementarne probe na mikročipu u procesu koji se zove hibridizacija. Ocitavanjem nivoa svetlosti emitovane iz svakog polja odredjuje se relativna zastupljenost te sekvence u uzorku. 1.6 RNA-Seq A major breakthrough (replaced microarrays) in the late 00’s and has been widely used since. Uses next-generation sequencing (NGS) to reveal the presence and quantity of RNA in a biological sample at a given moment. Able to detect novel (undiscovered) isoforms and has a broader dynamic range compapred to microarrays. Khan Academy ima odlicnu ilustraciju citavog procesa transkripcije ovde↩ Kodon = niz od 3 susedna nukleotida. Triplet je i najkraci niz nukleotida koji moze da kodira 20 razlicitih aminokiselina jer je \\(4^{3}&gt;20\\).↩ "],
["poravnanje.html", "2 Poravnanje 2.1 Alignment challenges 2.2 Tophat2 algorithm 2.3 Alignment file", " 2 Poravnanje * Ovo poglavlje je adaptirano iz rada koji opisuje TopHat2 aligner. 2.1 Alignment challenges The first step in the analysis process is to map the RNA-Seq reads against the reference genome, which provides the location from which the reads originated. In contrast to DNA-Seq alignment, RNA-Seq mapping algorithms have two additional challenges: Because genes contain introns, and because reads sequenced from mature mRNA transcripts do not include these introns, any RNA-Seq alignment algorithm must be able to handle gapped (or spliced) alignment with very large gaps. In mammalian genomes, introns span a very wide range of lengths, typically from 50 to 100,000 bases, which the alignment algorithm must accommodate. The presence of processed pseudogenes, from which some or all introns have been removed, may cause many exon-spanning reads to map incorrectly. This is particularly acute for the human genome, which contains over 14,000 pseudogenes. Pseudogeni su nefunkcionalni srodnici gena koji su izgubili sposobnost kodiranja proteina ili više ne bivaju izraženi u ćeliji. Mada neki od njih nemaju introne ili promotere (to su najčešće pseudogeni koji su kopirani sa mRNA i inkorporirani nazad u hromozome, poznati kao obrađeni/processed pseudogeni). Oni se smatraju nefunkcionalnim zbog njihovog nedostatka sposobnosti da kodiraju proteine, što je posledica raznih genetičkih oštećenja (prerani stop kodoni, pomeranja okvira čitanja, ili odsustva transkripcije), ili zbog njihove nesposobnosti da kodiraju RNA (kao kod rRNA pseudogena). Pseudogeni se generalno smatraju zadnjom stanicom genomskog materijala koja može biti uklonjena iz genoma, te se često obeležavaju kao junk DNA. Some numbers (Ensembl GRCh37 gene annotations, release 66 from 2012): average length of a mature mRNA transcript in the human genome is 2,227 bp. average exon length is 235 bp. average number of exons per transcript is 9.5. Assuming that sequencing reads are uniformly distributed along a transcript, we would expect 33 to 38% of 100 bp reads from an RNA-Seq experiment to span two or more exons. Note that this proportion increases significantly as read length increases. More important for the alignment problem is that around 20% of junction-spanning reads extend by 10 bp or less into one of the exons they span. A read extending a few bases into the flanking exon can be aligned to the intron instead of the exon. A read spanning multiple exons from genes with processed pseudogene copies can be aligned to the pseudogene copies instead of the gene from which it originates. How Tophat2 handles these issues: If a read extends only a few bases into one of two adjacent exons, then it often happens that the read will align equally well, but incorrectly, with the sequence of the intervening intron. To handle this problem, the appropriate algorithm detects potential splice sites for introns (GT-AG, GC-AG, and AT-AC). It uses these candidate splice sites in a subsequent step to correctly align multiexon-spanning reads. Concerning the human genome, for which there are relatively comprehensive annotations of protein-coding genes, the annotations can be used to map reads more accurately by aligning the reads preferentially to real genes rather than pseudogenes. 2.2 Tophat2 algorithm Given RNA-Seq reads as input, TopHat2 begins by mapping reads against the known transcriptome (if available). TopHat2 aligns unmapped reads against the genome. Any reads contained entirely within exons will be mapped, whereas other spanning introns may not be. Tophat interno koristi Bowtie aligner (od istih autora) za klasičan alignment. The unmapped reads are split into smaller non-overlapping segments (25 bp each by default) which are then aligned against the genome. Tophat2 examines any cases in which the left and right segments of the same read are mapped within a user-defined maximum intron size (usually between 50 and 100,000 bp). When this pattern is detected, TopHat2 re-aligns the entire read sequence to that genomic region in order to identify the most likely location of the splice site. It pays attention to the known junction signals (GT-AG, GC-AG, and AT-AC). The resulting spliced sequences are collected as a set of potential transcript fragments. Any reads not mapped in the previous stages (or mapped very poorly) are then re-aligned against this novel transcriptome. After these steps, some of the reads may have been aligned incorrectly by extending an exonic alignment a few bases into the adjacent intron. TopHat2 checks if such alignments extend into the introns identified in the split-alignment phase; if so, it can realign these reads to the adjacent exons instead. In the final stage, TopHat2 divides the reads into those with unique alignments and those with multiple alignments. For the multi-mapped reads, TopHat2 gathers statistical information (for example, the number of supporting reads) about the relevant splice junctions, insertions, and deletions, which it uses to recalculate the alignment score for each read. Based on these new alignment scores, TopHat2 reports the most likely alignment locations for such multi-mapped reads. For paired-end reads, TopHat2 processes the two reads separately through the same mapping stages described above. In the final stage, the independently aligned reads are analyzed together to produce paired alignments, taking into consideration additional factors including fragment length and orientation. 2.3 Alignment file CIGAR: a string describing how the read aligns with the reference. It consists of one or more components. Each component comprises an operator and the number of bases which the operator applies to. Operators are: MIDNSHP=X. https://broadinstitute.github.io/picard/explain-flags.html pysam is a Python package that wraps the functionality of the Samtools toolkit and enables many useful manipulations of SAM/BAM files. cigar types in pysam: 0 - alignment match (can be a sequence match or mismatch) 1 - insertion to the reference; 2 - deletion from the reference 3 - skipped region from the reference 4 - soft clipping (clipped sequences present in SEQ) 5 - hard clipping (clipped sequences NOT present in SEQ) 6 - padding (silent deletion from padded reference) 7 - sequence match 8 - sequence mismatch import pysam bamfile = pysam.AlignmentFile(&quot;/opt/aligned/sample_03_accepted_hits.bam&quot;, &quot;rb&quot;) for read in bamfile.fetch(): for (cigarType, cigarLength) in read.cigar: if cigarType == 3: print(read.cigar) print(read) break else: continue break ## [(0, 96), (3, 8645), (0, 4)] ## read56 99 0 87263 50 96M8645N4M 0 96010 100 CNGGGTGATCACTCAGAAGAAAAGGTGAATACCGGATGTTGTAAGCTATTGAACTGCCACAAGTGATATCTTTACACACCATTCTGCTGTCATAGGGTAG array(&#39;B&#39;, [40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40]) [(&#39;AS&#39;, -5), (&#39;XN&#39;, 0), (&#39;XM&#39;, 2), (&#39;XO&#39;, 0), (&#39;XG&#39;, 0), (&#39;NM&#39;, 2), (&#39;MD&#39;, &#39;1G91T6&#39;), (&#39;YT&#39;, &#39;UU&#39;), (&#39;XS&#39;, &#39;+&#39;), (&#39;NH&#39;, 1)] bamfile.close() "],
["kvantifikacija.html", "3 Kvantifikacija 3.1 Motivation for RNA-Seq quantification 3.2 RNA-Seq quantification 3.3 Gene level quantification 3.4 (Within-sample) Normalization", " 3 Kvantifikacija import time import pandas as pd import pysam 3.1 Motivation for RNA-Seq quantification Typical studies: DNA-Seq -&gt; alignment -&gt; variant calling -&gt; genome wide association study (GWAS); RNA-Seq -&gt; alignment -&gt; quantification -&gt; differential expression analysis 3.2 RNA-Seq quantification Pod pojmom kvantifikacije, u kontekstu RNA-Seq analize, podrazumevamo procenu relativne zastupljenosti mRNA molekula u uzorku. Counting versus probabilistic estimation dilemma is (mostly) about doing analysis on gene versus transcript level. - When quantifying on gene level - we simply count the number of reads aligned to each gene. - On transcript level, we need an algorithm such as the Expectation Maximization (EM, pictured below) to deal with the uncertainty. When performing statistical analysis of RNA expression, doing it on gene level compared to transcript level is more robust and experimentally actionable. The biologists will also usually draw their conclusions on gene level since that’s the level that the biological pathways are annotated on. However, the use of gene counts for statistical analysis can mask transcript-level dynamics. A popular alternative nowadays is to estimate the transcript abundances and then aggregate to gene level, or perform the entire analysis on trancsript level (testing for differential expression) and then aggregate the results. 3.3 Gene level quantification We shall, for simplicity’s sake, only perform gene level quantification. Even though it has some drawbacks, it’s a strategy still used by most genomic scientists. Here’s what we have at the beginning of the quantification step and what we want to estimate: We have: aligned reads and annotations. A file format called SAM/BAM is now the standard formats for next-generation sequence alignments. We estimate: relative abundance. We’ll start with some simple methods to find if two intervals overlap. def overlap(x, y): &quot;&quot;&quot; This function takes two intervals and determines whether they have any overlapping segments. &quot;&quot;&quot; new_start = max(x[1], y[1]) new_end = min(x[2], y[2]) if new_start &lt; new_end and x[0] == y[0]: return True return False We will define four intervals as tuples. region1 = (&quot;chr3&quot;, 27, 82) region2 = (&quot;chr4&quot;, 27, 82) region3 = (&quot;chr3&quot;, 57, 75) overlap(region1, region2) ## False overlap(region1, region3) ## True We shall now pick a gene of interest and try to find reads mapping to that gene. # the location of DEFB125 gene in human genome, gencode.v27 annotation gene = (&#39;chr20&#39;, 87249, 97094) To start exploring reads from a SAM/BAM file, we first need to load the file. # load BAM file bamfile = pysam.AlignmentFile(&quot;/opt/aligned/sample_01_accepted_hits.bam&quot;, &quot;rb&quot;) Note the ‘rb’ parameter indicates to read the file as binary, which is the BAM format (BAM stands for Binary Alignment Map). If loading a SAM file, this parameter does not need to be specified. An important and very common application is to count the number of reads (aligned fragments) that overlap a given feature (i.e. region of the genome or gene). One simple approach to doing this is to make a list of all reads generated and simply iterate over the reads to identify whether a read overlaps a region. In this case we need an overlap method that can compare a simple interval (defined by a tuple of sequence, start, end) with a pysam AlignedSegment object. This overlap method also needs the AlignmentFile object to decode the chromosome name. def overlap(x, gene, bamfile): &quot;&quot;&quot; A modified version of overlap that takes an interval and a pysam AlignedSegment and tests for overlap &quot;&quot;&quot; new_start = max(x.reference_start, gene[1]) new_end = min(x.reference_end, gene[2]) if (new_start &lt; new_end and bamfile.getrname(x.tid) == gene[0]): return True return False start_time = time.time() # code to iterate over reads and count for a single gene naive_gene_count = 0 for x in bamfile.fetch(): # Note x is of type pysam.AlignedSegment if(overlap(x, gene, bamfile)): naive_gene_count += 1 print(&quot;--- %s seconds ---&quot; % (time.time() - start_time)) ## --- 2.872087240219116 seconds --- print(naive_gene_count) ## 1016 The problem with this approach is that to do this, you will need to store the entire file in memory. Worse than that, in order to find the reads within a single gene, you would need to iterate over the entire file, which can contain hundreds of millions of reads. This is quite slow even for a single gene, but will only increase if you want to look at many genes. Instead, more efficient datastructures (and indexing schemes) can be used to retrieve reads based on positions in more efficient ways. To get the reads overlapping a given region, Pysam has a method called fetch(), which takes the genomic coordinates and returns an iterator of all reads overlapping that region. bam_iter = bamfile.fetch(gene[0], gene[1], gene[2]) start_time = time.time() pysam_gene_count = 0 for x in bam_iter: pysam_gene_count += 1 print(&quot;--- %s seconds ---&quot; % (time.time() - start_time)) ## --- 0.011068582534790039 seconds --- print(pysam_gene_count) ## 1016 Not surprisingly, they are the same - the big difference is that the second method is significantly faster. The reason for this is that Pysam (like Samtools, Picard, and other similar toolkits) make use of clever tricks to index the file by genomic positions to more efficiently search for reads within a given genomic interval. Now that we know how to count reads overlapping a region, we can write this as a function and try and compute this for all genes. def read_count(gene, bamfile): &quot;&quot;&quot; Compute the number of reads contained in a bamfile that overlap a given interval &quot;&quot;&quot; bam_iter = bamfile.fetch(gene[0], gene[1], gene[2]) pysam_gene_count = 0 for x in bam_iter: pysam_gene_count += 1 return pysam_gene_count You can run this with any gene tuple now: # the location of ZNFX1 gene in human genome, gencode.v27 annotation gene2 = (&quot;chr20&quot;, 49237945, 49278426) read_count(gene2, bamfile) ## 5282 Now, let’s compute the gene counts for all genes. We’ll start by reading in all genes: start_time = time.time() gene_counts={} with open(&#39;/opt/gencode.v27.chr20.bed&#39;, &#39;r&#39;) as f: for line in f: tokens = line.split(&#39;\\t&#39;) gene_local = (tokens[0], int(tokens[1]), int(tokens[2])) count = read_count(gene_local, bamfile) gene_counts.update({tokens[3].rstrip() : count}) print(&quot;--- %s seconds ---&quot; % (time.time() - start_time)) ## --- 1.663689136505127 seconds --- Now it’s easy to query the gene counts for different genes. print(gene_counts.get(&quot;ARFGEF2&quot;)) ## 7283 print(gene_counts.get(&quot;SOX12&quot;)) ## 3836 print(gene_counts.get(&quot;WFDC8&quot;)) ## 1641 3.4 (Within-sample) Normalization In previous slides, we’ve seen how we can compute raw counts, i.e. number of reads that align to a particular feature (gene or transcript). \\[X_{i}\\] These numbers are heavily dependent on two things: - The amount of fragments sequenced - The length of the feature, or more appropriately, the effective length. Effective length refers to the number of possible start sites a feature could have generated a fragment of that particular length. In practice, the effective length is usually computed as: \\[\\widetilde{l_{i}}=l_{i}-\\mu_{FLD}+1\\] Since counts are NOT scaled by the length of the feature, all units in this category are not comparable within a sample without adjusting for the feature length! 3.4.1 Different units Reads Per Kilobase per Million reads mapped (RPKM), or for the paired-end reads: FPKM (Fragments instead of Reads). \\[FPKM_{i}=\\frac{X_i}{\\left ( \\frac{\\widetilde{l_{i}}}{10^{3}}\\left ( \\frac{N}{10^{6}} \\right ) \\right )} = \\frac{X_i}{\\widetilde{l_{i}}N}\\cdot 10^{9}\\] Transcripts Per Million (TPM) \\[TPM_{i}=\\frac{X_i}{\\widetilde{l_{i}}}\\cdot \\left ( \\frac{1}{\\Sigma_{j}\\frac{X_j}{\\widetilde{l_{j}}}} \\right ) \\cdot 10^{6}\\] counts = {&#39;Gene Name&#39;: [&#39;A(5kb)&#39;, &#39;B(10kb)&#39;, &#39;C(1kb)&#39;, &#39;D(20kb)&#39;], &#39;Rep1 Counts&#39;: [1000000, 2000000, 1000000, 0], &#39;Rep2 Counts&#39;: [12, 25, 8, 0], &#39;Rep3 Counts&#39;: [30, 60, 15, 1] } df = pd.DataFrame(counts, columns= [&#39;Gene Name&#39;, &#39;Rep1 Counts&#39;, &#39;Rep2 Counts&#39;, &#39;Rep3 Counts&#39;]).set_index(&#39;Gene Name&#39;) df ## Rep1 Counts Rep2 Counts Rep3 Counts ## Gene Name ## A(5kb) 1000000 12 30 ## B(10kb) 2000000 25 60 ## C(1kb) 1000000 8 15 ## D(20kb) 0 0 1 Let’s first calculate the abundances in FPKM units. We first divide by the total number of reads: df_rpkm = df.div(df.sum()/1000000).round(2) df_rpkm ## Rep1 Counts Rep2 Counts Rep3 Counts ## Gene Name ## A(5kb) 250000.0 266666.67 283018.87 ## B(10kb) 500000.0 555555.56 566037.74 ## C(1kb) 250000.0 177777.78 141509.43 ## D(20kb) 0.0 0.00 9433.96 Then we normalize for gene length: # save gene sizes in new column df_rpkm[&#39;kb&#39;] = [5,10,1,20] # gene size normalization df_rpkm = df_rpkm.div(df_rpkm.kb, axis=0).round(2) df_rpkm.drop([&#39;kb&#39;], axis=1) ## Rep1 Counts Rep2 Counts Rep3 Counts ## Gene Name ## A(5kb) 50000.0 53333.33 56603.77 ## B(10kb) 50000.0 55555.56 56603.77 ## C(1kb) 250000.0 177777.78 141509.43 ## D(20kb) 0.0 0.00 471.70 The sums of total normalized counts in each column are not equal as we prove below: # FPKM normalization sums per samples are not equal (samples are not comparable). df_rpkm.drop([&#39;kb&#39;], axis=1).sum() ## Rep1 Counts 350000.00 ## Rep2 Counts 286666.67 ## Rep3 Counts 255188.67 ## dtype: float64 Now we will calculate the abundances in TPM units. Here, the first thing we do is normalize for gene length! df_tpm = df # save gene sizes in new column df_tpm[&#39;kb&#39;] = [2,4,1,10] # gene size normalization is performed first df_tpm = df_tpm.div(df_tpm.kb, axis=0).round(2) df_tpm.drop([&#39;kb&#39;], axis=1) ## Rep1 Counts Rep2 Counts Rep3 Counts ## Gene Name ## A(5kb) 500000.0 6.00 15.0 ## B(10kb) 500000.0 6.25 15.0 ## C(1kb) 1000000.0 8.00 15.0 ## D(20kb) 0.0 0.00 0.1 And now we perform the library size normalization, using abundances already normalized for gene length: # library size normalization (division by 10 instead of 10^6) df_tpm = df_tpm.div(df_tpm.sum()/10).round(3) df_tpm.drop([&#39;kb&#39;], axis=1) ## Rep1 Counts Rep2 Counts Rep3 Counts ## Gene Name ## A(5kb) 2.5 2.963 3.326 ## B(10kb) 2.5 3.086 3.326 ## C(1kb) 5.0 3.951 3.326 ## D(20kb) 0.0 0.000 0.022 The sums of total normalized counts in each column are now equal (when using TPM)! # TPM normalization sums per samples are equal (samples are comparable). df_tpm.drop([&#39;kb&#39;], axis=1).sum() ## Rep1 Counts 10.0 ## Rep2 Counts 10.0 ## Rep3 Counts 10.0 ## dtype: float64 def tpm(genefile, bamfile): &quot;&quot;&quot; Compute the TPM (transcripts per million) metric for all genes within the genefile using an RNA-Seq bamfile &quot;&quot;&quot; total_mapped_reads = 0 # here you want all reads bam_iter = bamfile.fetch() for x in bam_iter: total_mapped_reads += 1 gene_counts = {} with open(genefile, &#39;r&#39;) as f: for line in f: tokens = line.split(&#39;\\t&#39;) gene_local = (tokens[0], int(tokens[1]), int(tokens[2])) gene_length = gene_local[2] - gene_local[1] raw_count = read_count(gene_local, bamfile) if tokens[3] in gene_counts: gene_counts[tokens[3]] = (gene_counts[tokens[3]][0] + raw_count, gene_length) else: gene_counts.update({tokens[3].rstrip() : (raw_count, gene_length)}) countsDF = pd.DataFrame(gene_counts, index=[&#39;raw_count&#39;, &#39;gene_length&#39;]) countsDF = countsDF.T X=countsDF.iloc[:,0].values l=countsDF.iloc[:,1].values countsDF = countsDF.assign(tpm = 1e6 * (X/l) / (X/l).sum()) return(countsDF) start_time = time.time() gene_counts = tpm(&#39;/opt/gencode.v27.chr20.bed&#39;, bamfile) print(&quot;--- %s seconds ---&quot; % (time.time() - start_time)) ## --- 3.323309898376465 seconds --- gene_counts.head(10) ## raw_count gene_length tpm ## DEFB125 1016 9845 162.980261 ## DEFB126 559 3383 260.955726 ## DEFB127 419 1694 390.622844 ## DEFB128 368 1829 317.754079 ## DEFB129 395 2629 237.281309 ## DEFB132 3381 3361 1588.669944 ## AL034548.1 1218 1672 1150.450762 ## C20orf96 1035 19916 82.072045 ## ZCCHC3 2748 3354 1293.929728 ## NRSN2-AS1 4344 27912 245.785286 def rpkm(genefile, bamfile): &quot;&quot;&quot; Compute the RPKM (reads per kilobase per million mapped reads) metric for all genes within the genefile using an RNA-Seq bamfile &quot;&quot;&quot; total_mapped_reads = 0 # here you want all reads bam_iter = bamfile.fetch() for x in bam_iter: total_mapped_reads += 1 gene_counts = {} with open(genefile, &#39;r&#39;) as f: for line in f: tokens = line.split(&#39;\\t&#39;) gene_local = (tokens[0], int(tokens[1]), int(tokens[2])) gene_length=gene_local[2]-gene_local[1] raw_count = read_count(gene_local, bamfile) rpk_metric = 1e9 * raw_count \\ / (total_mapped_reads * gene_length) gene_counts.update({tokens[3].rstrip() : (raw_count, gene_length, rpk_metric)}) countsDF = pd.DataFrame(gene_counts, index=[&#39;raw_count&#39;, &#39;gene_length&#39;, &#39;rpkm&#39;]) countsDF = countsDF.T return(countsDF) start_time = time.time() gene_counts_rpkm = rpkm(&#39;/opt/gencode.v27.chr20.bed&#39;, bamfile) print(&quot;--- %s seconds ---&quot; % (time.time() - start_time)) ## --- 2.5380518436431885 seconds --- gene_counts_rpkm.head(10) ## raw_count gene_length rpkm ## DEFB125 1016.0 9845.0 61.832560 ## DEFB126 559.0 3383.0 99.003158 ## DEFB127 419.0 1694.0 148.197152 ## DEFB128 368.0 1829.0 120.551704 ## DEFB129 395.0 2629.0 90.021397 ## DEFB132 3381.0 3361.0 602.720410 ## AL034548.1 1218.0 1672.0 436.465836 ## C20orf96 1035.0 19916.0 31.137051 ## ZCCHC3 2748.0 3354.0 490.899862 ## NRSN2-AS1 4344.0 27912.0 93.247694 "]
]
